/*
 * OpenGL texture manager
 *
 * Copyright (C) 1996-2001 Id Software, Inc.
 * Copyright (C) 2002-2009 John Fitzgibbons and others
 * Copyright (C) 2007-2008 Kristian Duske
 * Copyright (C) 2010-2014 QuakeSpasm developers
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 */

#include "quakedef.h"
#include "glquake.h"

static cvar_t gl_texturemode = { "gl_texturemode", "", CVAR_ARCHIVE };
static cvar_t gl_texture_anisotropy = { "gl_texture_anisotropy", "0", CVAR_ARCHIVE };
static cvar_t gl_max_size = { "gl_max_size", "0", CVAR_NONE };

static GLint gl_hardware_maxsize;

typedef struct gltexture_s
{
	GLuint texnum;
	struct gltexture_s *next;

	char name[64];
	unsigned int flags;
	enum srcformat source_format; //format of pixel data (indexed, lightmap, or rgba)
	unsigned int source_width; //size of image in source data
	unsigned int source_height; //size of image in source data
	byte *source_data;
	unsigned short source_crc; //generated by source data before modifications

	unsigned int width; //size of image as it exists in opengl
	unsigned int height; //size of image as it exists in opengl
} gltexture_t;

#define	MAX_GLTEXTURES	2048
static gltexture_t *active_gltextures;

gltexture_t *notexture;
gltexture_t *nulltexture;

unsigned int d_8to24table[256];
unsigned int d_8to24table_fbright[256];
unsigned int d_8to24table_fbright_fence[256];

// current texture in each texture unit cache
#define	GL_UNUSED_TEXTURE (~(GLuint)0)
static GLuint currenttexture[3] = { GL_UNUSED_TEXTURE, GL_UNUSED_TEXTURE, GL_UNUSED_TEXTURE };
static GLenum currenttarget = GL_TEXTURE0;
bool mtexenabled = false;

void GL_SelectTextureUnit(GLenum target)
{
        if (target == currenttarget)
                return;

        glActiveTexture(target);

        currenttarget = target;
}

void GL_Bind(gltexture_t *texture)
{
	if (!texture)
		texture = nulltexture;

	if (texture->texnum != currenttexture[currenttarget - GL_TEXTURE0])
	{
		currenttexture[currenttarget - GL_TEXTURE0] = texture->texnum;
		glBindTexture(GL_TEXTURE_2D, texture->texnum);
	}
}

void GL_BindToUnit(GLenum target, gltexture_t *texture)
{
	if (!texture)
		texture = nulltexture;

	if (texture->texnum != currenttexture[target - GL_TEXTURE0])
	{
		GL_SelectTextureUnit(target);
		currenttexture[currenttarget - GL_TEXTURE0] = texture->texnum;
		glBindTexture(GL_TEXTURE_2D, texture->texnum);
	}
}

/*
 * Wrapper around glDeleteTextures that also clears the given texture number
 * from our per-TMU cached texture binding table.
 */
static void GL_DeleteTexture(gltexture_t *texture)
{
	glDeleteTextures(1, &texture->texnum);

	if (texture->texnum == currenttexture[0])
		currenttexture[0] = GL_UNUSED_TEXTURE;
	if (texture->texnum == currenttexture[1])
		currenttexture[1] = GL_UNUSED_TEXTURE;

	texture->texnum = 0;
}

/*
 ================================================================================

 COMMANDS

 ================================================================================
 */

typedef struct
{
	GLint magfilter;
	GLint minfilter;
	const char *name;
} glmode_t;
static glmode_t glmodes[] = {
	{ GL_NEAREST, GL_NEAREST,                "GL_NEAREST" },
	{ GL_NEAREST, GL_NEAREST_MIPMAP_NEAREST, "GL_NEAREST_MIPMAP_NEAREST" },
	{ GL_NEAREST, GL_NEAREST_MIPMAP_LINEAR,  "GL_NEAREST_MIPMAP_LINEAR" },
	{ GL_LINEAR,  GL_LINEAR,                 "GL_LINEAR" },
	{ GL_LINEAR,  GL_LINEAR_MIPMAP_NEAREST,  "GL_LINEAR_MIPMAP_NEAREST" },
	{ GL_LINEAR,  GL_LINEAR_MIPMAP_LINEAR,   "GL_LINEAR_MIPMAP_LINEAR" },
};
#define NUM_GLMODES (int)(sizeof(glmodes)/sizeof(glmodes[0]))
static int glmode_idx = NUM_GLMODES - 1; /* trilinear */

/* report available texturemodes */
static void TexMgr_DescribeTextureModes_f(void)
{
	int i;

	for (i = 0; i < NUM_GLMODES ; i++)
		Con_SafePrintf("   %2i: %s\n", i + 1, glmodes[i].name);

	Con_Printf("%i modes\n", i);
}

static void TexMgr_SetFilterModes(gltexture_t *glt)
{
	GL_Bind(glt);

	if (glt->flags & TEX_NEAREST)
	{
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	}
	else if (glt->flags & TEX_LINEAR)
	{
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	}
	else if (glt->flags & TEX_MIPMAP)
	{
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, glmodes[glmode_idx].magfilter);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, glmodes[glmode_idx].minfilter);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, gl_texture_anisotropy.value);
	}
	else
	{
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	}
}

/* called when gl_texturemode changes */
static void TexMgr_TextureMode_f(cvar_t *var)
{
	gltexture_t *glt;
	int i;

	for (i = 0; i < NUM_GLMODES ; i++)
	{
		if (!strcmp(glmodes[i].name, gl_texturemode.string))
		{
			if (glmode_idx != i)
			{
				glmode_idx = i;
				for (glt = active_gltextures; glt; glt = glt->next)
					TexMgr_SetFilterModes(glt);
			}
			return;
		}
	}

	for (i = 0; i < NUM_GLMODES ; i++)
	{
		if (!strcasecmp(glmodes[i].name, gl_texturemode.string))
		{
			Cvar_SetQuick(&gl_texturemode, glmodes[i].name);
			return;
		}
	}

	i = atoi(gl_texturemode.string);
	if (i >= 1 && i <= NUM_GLMODES)
	{
		Cvar_SetQuick(&gl_texturemode, glmodes[i - 1].name);
		return;
	}

	Con_Printf("\"%s\" is not a valid texturemode\n", gl_texturemode.string);
	Cvar_SetQuick(&gl_texturemode, glmodes[glmode_idx].name);
}

/* called when gl_texture_anisotropy changes */
static void TexMgr_Anisotropy_f(cvar_t *var)
{
	if (gl_texture_anisotropy.value < 1)
	{
		Cvar_SetQuick(&gl_texture_anisotropy, "1");
	}
	else if (gl_texture_anisotropy.value > gl_max_anisotropy)
	{
		Cvar_SetValueQuick(&gl_texture_anisotropy, gl_max_anisotropy);
	}
	else
	{
		gltexture_t *glt;
		for (glt = active_gltextures; glt; glt = glt->next)
		{
			/*  TexMgr_SetFilterModes (glt);*/
			if (glt->flags & TEX_MIPMAP)
			{
				GL_Bind(glt);
				glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, glmodes[glmode_idx].magfilter);
				glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, glmodes[glmode_idx].minfilter);
				glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, gl_texture_anisotropy.value);
			}
		}
	}
}

/* report loaded textures */
static void TexMgr_Imagelist_f(void)
{
	float texels = 0;
	int count = 0;

	for (gltexture_t *glt = active_gltextures; glt; glt = glt->next)
	{
		Con_SafePrintf("   %4i x%4i %s\n", glt->width, glt->height, glt->name);
		if (glt->flags & TEX_MIPMAP)
			texels += glt->width * glt->height * 4.0f / 3.0f;
		else
			texels += (glt->width * glt->height);
		count++;
	}

	float mb = texels * (Cvar_VariableValue("vid_bpp") / 8.0f) / 0x100000;
	Con_Printf("%i textures %i pixels %1.1f megabytes\n", count, (int) texels, mb);
}

#ifndef OPENGLES
typedef struct targaheader_s {
	unsigned char 	id_length, colormap_type, image_type;
	unsigned short	colormap_index, colormap_length;
	unsigned char	colormap_size;
	unsigned short	x_origin, y_origin, width, height;
	unsigned char	pixel_size, attributes;
} targaheader_t;

#define TARGAHEADERSIZE 18 //size on disk

/* writes RGB or RGBA data to a TGA file */
static bool Image_WriteTGA (const char *name, byte *data, int width, int height, int bpp, bool upsidedown)
{
	int size, temp, bytes;
	byte header[TARGAHEADERSIZE];

	FILE *handle = COM_FileOpenWrite(name);
	if (!handle)
		return false;

	memset (&header, 0, TARGAHEADERSIZE);
	header[2] = 2; // uncompressed type
	header[12] = width&255;
	header[13] = width>>8;
	header[14] = height&255;
	header[15] = height>>8;
	header[16] = bpp; // pixel size
	if (upsidedown)
		header[17] = 0x20; //upside-down attribute

	// swap red and blue bytes
	bytes = bpp/8;
	size = width*height*bytes;
	for (int i=0; i<size; i+=bytes)
	{
		temp = data[i];
		data[i] = data[i+2];
		data[i+2] = temp;
	}

	Sys_FileWrite (handle, &header, TARGAHEADERSIZE);
	Sys_FileWrite (handle, data, size);
	Sys_FileClose (handle);

	return true;
}

/* dump all current textures to TGA files */
static void TexMgr_Imagedump_f (void)
{
	char tganame[MAX_OSPATH], tempname[MAX_OSPATH], dirname[MAX_OSPATH];
	gltexture_t *glt;
	byte *buffer;
	char *c;
	int count = 0;

	//create directory
	snprintf(dirname, sizeof(dirname), "%s/imagedump", com_gamedir);
	Sys_mkdir (dirname);

	//loop through textures
	for (glt = active_gltextures; glt; glt = glt->next)
	{
		strlcpy (tempname, glt->name, sizeof(tempname));
		while ( (c = strchr(tempname, ':')) ) *c = '_';
		while ( (c = strchr(tempname, '/')) ) *c = '_';
		while ( (c = strchr(tempname, '*')) ) *c = '_';
		snprintf(tganame, sizeof(tganame), "imagedump/%s.tga", tempname);

		GL_Bind (glt);
		if (glt->flags & TEX_ALPHA)
		{
			buffer = (byte *)Q_malloc(glt->width*glt->height*4);
			glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
			Image_WriteTGA(tganame, buffer, glt->width, glt->height, 32, true);
		}
		else
		{
			buffer = (byte *)Q_malloc(glt->width*glt->height*3);
			glGetTexImage(GL_TEXTURE_2D, 0, GL_RGB, GL_UNSIGNED_BYTE, buffer);
			Image_WriteTGA(tganame, buffer, glt->width, glt->height, 24, true);
		}
		free (buffer);

		count++;
	}

	Con_Printf ("dumped %i textures to %s\n", count, dirname);
}
#endif

static gltexture_t *TexMgr_FindTexture(const char *name)
{
	gltexture_t *glt;

	if (name)
	{
		for (glt = active_gltextures; glt; glt = glt->next)
		{
			if (!strcmp(glt->name, name))
				return glt;
		}
	}

	return NULL;
}

void TexMgr_FreeTexture(gltexture_t *kill)
{
	if (kill == NULL)
	{
		Con_Printf("TexMgr_FreeTexture: NULL texture\n");
		return;
	}

	if (active_gltextures == kill)
	{
		active_gltextures = kill->next;
		GL_DeleteTexture(kill);
		free(kill->source_data);
		free(kill);
		return;
	}

	for (gltexture_t *glt = active_gltextures; glt; glt = glt->next)
	{
		if (glt->next == kill)
		{
			glt->next = kill->next;
			GL_DeleteTexture(kill);
			free(kill->source_data);
			free(kill);
			return;
		}
	}

	Con_Printf("TexMgr_FreeTexture: not found\n");
}

/* return smallest power of two greater than or equal to s */
static int TexMgr_PadUp(int s)
{
	int i;
	for (i = 1; i < s; i <<= 1)
		;
	return i;
}

/* return largest power of two less than or equal to s */
static int TexMgr_PadDown(int s)
{
	int i;
	for (i = 1; i < s; i <<= 1)
		;
	if (i == s)
		return i;
	else
		return i >> 1;
}

/* return a size with hardware and user prefs in mind*/
unsigned int TexMgr_SafeTextureSize(int s)
{
	if ((int)gl_max_size.value > 0 && s > (int)gl_max_size.value)
	{
		s = gl_max_size.value;
		if (!gl_texture_NPOT)
			s = TexMgr_PadDown(gl_max_size.value);
	}

	if (!gl_texture_NPOT)
		s = TexMgr_PadUp(s);

	// Hardware max size assumed to be POT
	s = min(gl_hardware_maxsize, s);

	return s;
}

/* only pad if a texture of that size would be padded */
//static int TexMgr_PadConditional(int s)
//{
//	if (s < TexMgr_SafeTextureSize(s))
//		return TexMgr_Pad(s);
//	else
//		return s;
//}

/* bilinear resample */
static void TexMgr_ResampleTexture32(unsigned *out, int outwidth, int outheight, const unsigned *in, int inwidth, int inheight)
{
	const byte *nwpx, *nepx, *swpx, *sepx;
	byte *dest;
	unsigned xfrac, yfrac, x, y, modx, mody, imodx, imody, injump, outjump;
	int i, j;

	xfrac = ((inwidth - 1) << 16) / (outwidth - 1);
	yfrac = ((inheight - 1) << 16) / (outheight - 1);
	y = outjump = 0;

	for (i = 0; i < outheight; i++)
	{
		mody = (y >> 8) & 0xFF;
		imody = 256 - mody;
		injump = (y >> 16) * inwidth;
		x = 0;

		for (j = 0; j < outwidth; j++)
		{
			modx = (x >> 8) & 0xFF;
			imodx = 256 - modx;

			nwpx = (const byte *) (in + (x >> 16) + injump);
			nepx = nwpx + 4;
			swpx = nwpx + inwidth * 4;
			sepx = swpx + 4;

			dest = (byte *) (out + outjump + j);

			dest[0] = (nwpx[0] * imodx * imody + nepx[0] * modx * imody + swpx[0] * imodx * mody + sepx[0] * modx * mody) >> 16;
			dest[1] = (nwpx[1] * imodx * imody + nepx[1] * modx * imody + swpx[1] * imodx * mody + sepx[1] * modx * mody) >> 16;
			dest[2] = (nwpx[2] * imodx * imody + nepx[2] * modx * imody + swpx[2] * imodx * mody + sepx[2] * modx * mody) >> 16;
			dest[3] = (nwpx[3] * imodx * imody + nepx[3] * modx * imody + swpx[3] * imodx * mody + sepx[3] * modx * mody) >> 16;

			x += xfrac;
		}
		outjump += outwidth;
		y += yfrac;
	}
}

/*
 * eliminate pink edges on sprites, etc.
 * operates in place on 32bit data
 */
//static void TexMgr_AlphaEdgeFix(unsigned int *data, int width, int height)
//{
//	int n = 0;
//	int b;
//	int c[3] = { 0, 0, 0 };
//	int lastrow;
//	int thisrow;
//	int nextrow;
//	int lastpix;
//	int thispix;
//	int nextpix;
//	byte *dest = (byte *)data;
//
//	for (size_t i = 0; i < height; i++)
//	{
//		lastrow = width * 4 * ((i == 0) ? height - 1 : i - 1);
//		thisrow = width * 4 * i;
//		nextrow = width * 4 * ((i == height - 1) ? 0 : i + 1);
//
//		for (size_t j = 0; j < width; j++, dest += 4)
//		{
//			if (dest[3]) //not transparent
//				continue;
//
//			lastpix = 4 * ((j == 0) ? width - 1 : j - 1);
//			thispix = 4 * j;
//			nextpix = 4 * ((j == width - 1) ? 0 : j + 1);
//
//			b = lastrow + lastpix;
//			if (data[b + 3])
//			{
//				c[0] += data[b];
//				c[1] += data[b + 1];
//				c[2] += data[b + 2];
//				n++;
//			}
//			b = thisrow + lastpix;
//			if (data[b + 3])
//			{
//				c[0] += data[b];
//				c[1] += data[b + 1];
//				c[2] += data[b + 2];
//				n++;
//			}
//			b = nextrow + lastpix;
//			if (data[b + 3])
//			{
//				c[0] += data[b];
//				c[1] += data[b + 1];
//				c[2] += data[b + 2];
//				n++;
//			}
//			b = lastrow + thispix;
//			if (data[b + 3])
//			{
//				c[0] += data[b];
//				c[1] += data[b + 1];
//				c[2] += data[b + 2];
//				n++;
//			}
//			b = nextrow + thispix;
//			if (data[b + 3])
//			{
//				c[0] += data[b];
//				c[1] += data[b + 1];
//				c[2] += data[b + 2];
//				n++;
//			}
//			b = lastrow + nextpix;
//			if (data[b + 3])
//			{
//				c[0] += data[b];
//				c[1] += data[b + 1];
//				c[2] += data[b + 2];
//				n++;
//			}
//			b = thisrow + nextpix;
//			if (data[b + 3])
//			{
//				c[0] += data[b];
//				c[1] += data[b + 1];
//				c[2] += data[b + 2];
//				n++;
//			}
//			b = nextrow + nextpix;
//			if (data[b + 3])
//			{
//				c[0] += data[b];
//				c[1] += data[b + 1];
//				c[2] += data[b + 2];
//				n++;
//			}
//
//			//average all non-transparent neighbors
//			if (n)
//			{
//				dest[0] = (byte) (c[0] / n);
//				dest[1] = (byte) (c[1] / n);
//				dest[2] = (byte) (c[2] / n);
//
//				n = c[0] = c[1] = c[2] = 0;
//			}
//		}
//	}
//}

/*
 * special case of AlphaEdgeFix for textures that only need it because they were padded
 * operates in place on 32bit data, and expects unpadded height and width values
 */
//static void TexMgr_PadEdgeFixW(unsigned int *in_data, int width, int height)
//{
//	byte *src, *dst, *data = (byte *)in_data;
//	int i, padw, padh;
//
//	padw = TexMgr_PadConditional(width);
//	padh = TexMgr_PadConditional(height);
//
//	//copy last full column to first empty column, leaving alpha byte at zero
//	src = data + (width - 1) * 4;
//	for (i = 0; i < padh; i++)
//	{
//		src[4] = src[0];
//		src[5] = src[1];
//		src[6] = src[2];
//		src += padw * 4;
//	}
//
//	//copy first full column to last empty column, leaving alpha byte at zero
//	src = data;
//	dst = data + (padw - 1) * 4;
//	for (i = 0; i < padh; i++)
//	{
//		dst[0] = src[0];
//		dst[1] = src[1];
//		dst[2] = src[2];
//		src += padw * 4;
//		dst += padw * 4;
//	}
//}

/*
 * special case of AlphaEdgeFix for textures that only need it because they were padded
 * operates in place on 32bit data, and expects unpadded height and width values
 */
//static void TexMgr_PadEdgeFixH(unsigned int *in_data, int width, int height)
//{
//	byte *src, *dst, *data = (byte *)in_data;
//	int i, padw, padh;
//
//	padw = TexMgr_PadConditional(width);
//	padh = TexMgr_PadConditional(height);
//
//	//copy last full row to first empty row, leaving alpha byte at zero
//	dst = data + height * padw * 4;
//	src = dst - padw * 4;
//	for (i = 0; i < padw; i++)
//	{
//		dst[0] = src[0];
//		dst[1] = src[1];
//		dst[2] = src[2];
//		src += 4;
//		dst += 4;
//	}
//
//	//copy first full row to last empty row, leaving alpha byte at zero
//	dst = data + (padh - 1) * padw * 4;
//	src = data;
//	for (i = 0; i < padw; i++)
//	{
//		dst[0] = src[0];
//		dst[1] = src[1];
//		dst[2] = src[2];
//		src += 4;
//		dst += 4;
//	}
//}

/* return image padded up to power-of-two dimentions */
//static void TexMgr_PadImage8(byte *out, int out_width, int out_height, const byte *in, int in_width, int in_height, byte padbyte)
//{
//	if (out_width < in_width || out_height < in_height)
//		Sys_Error("Cannot pad down");
//
//	int h = 0;
//	for (; h < in_height; h++)
//	{
//		int j = 0;
//		for (; j < in_width; j++)
//			*out++ = *in++;
//		for (; j < out_width; j++)
//			*out++ = padbyte;
//	}
//	for (; h < out_height; h++)
//		for (int w = 0; w < out_width; w++)
//			*out++ = padbyte;
//}

static void TexMgr_MipMapW(unsigned *data, unsigned int width, unsigned int height)
{
	unsigned int mipwidth = width >> 1;

	for (size_t h = 0; h < height; h++)
	{
		unsigned *mipline = &data[h * mipwidth];
		unsigned *line = &data[h * width];
		for (size_t w = 0; w < mipwidth; w++)
		{
			uint8_t *mip = (uint8_t *)&mipline[w];
			uint8_t *texel1 = (uint8_t *)&line[(w * 2) + 0];
			uint8_t *texel2 = (uint8_t *)&line[(w * 2) + 1];

			for (size_t k = 0; k < 4; k++)
				mip[k] = (texel1[k] + texel2[k]) / 2;
		}
	}
}

static void TexMgr_MipMapH(unsigned *data, unsigned int width, unsigned int height)
{
	unsigned int mipheight = height >> 1;

	for (size_t h = 0; h < mipheight; h++)
	{
		unsigned *mipline = &data[h * width];
		unsigned *line1 = &data[((h * 2) + 0) * width];
		unsigned *line2 = &data[((h * 2) + 1) * width];
		for (size_t w = 0; w < width; w++)
		{
			uint8_t *mip = (uint8_t *)&mipline[w];
			uint8_t *texel1 = (uint8_t *)&line1[w];
			uint8_t *texel2 = (uint8_t *)&line2[w];

			for (size_t k = 0; k < 4; k++)
				mip[k] = (texel1[k] + texel2[k]) / 2;
		}
	}
}

static void TexMgr_UploadMips32(unsigned *data, unsigned int width, unsigned int height)
{
	for (int miplevel = 1; width > 1 || height > 1; miplevel++)
	{
		if (width > 1)
		{
			TexMgr_MipMapW(data, width, height);
			width >>= 1;
		}
		if (height > 1)
		{
			TexMgr_MipMapH(data, width, height);
			height >>= 1;
		}
//		TexMgr_ResampleTexture32(data, width, height, data, bwidth, height);
		glTexImage2D(GL_TEXTURE_2D, miplevel, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
	}
}

/* handles 32bit source data */
static void TexMgr_LoadImage32(gltexture_t *glt, const unsigned *data, unsigned int width, unsigned int height)
{
	GL_Bind(glt);

	// need to resample
	if (TexMgr_SafeTextureSize(width) != width ||
	    TexMgr_SafeTextureSize(height) != height)
	{
		unsigned int resampled_width = TexMgr_SafeTextureSize(width);
		unsigned int resampled_height = TexMgr_SafeTextureSize(height);
		unsigned *resampled_data = (unsigned *)Q_malloc(sizeof(*resampled_data) * (resampled_width * resampled_height));
		TexMgr_ResampleTexture32(resampled_data, resampled_width, resampled_height, data, width, height);
		// upload base
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, resampled_width, resampled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, resampled_data);
		// upload mips
		if (glt->flags & TEX_MIPMAP)
			TexMgr_UploadMips32(resampled_data, resampled_width, resampled_height);
		free(resampled_data);

		glt->width = resampled_width;
		glt->height = resampled_height;
	}
	else
	{
		// upload base
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
		// upload mips
		if (glt->flags & TEX_MIPMAP)
		{
			// Mipmapping is done in place right now so clone const data
			unsigned *nonconst_data = (unsigned *)Q_malloc(sizeof(*nonconst_data) * (width * height));
			memcpy(nonconst_data, data, sizeof(*nonconst_data) * (width * height));
			TexMgr_UploadMips32(nonconst_data, width, height);
			free(nonconst_data);
		}

		glt->width = width;
		glt->height = height;
	}

	// set filter modes
	TexMgr_SetFilterModes(glt);
}

/* handles lightmap data */
static void TexMgr_LoadLightmap(gltexture_t *glt, const byte *data, unsigned int width, unsigned int height)
{
	// upload it
	GL_Bind(glt);

#ifdef OPENGLES
	GLenum format = GL_LUMINANCE;
#else
	GLenum format = GL_RED;
#endif

	glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);

	glt->width = width;
	glt->height = height;

	// set filter modes
	TexMgr_SetFilterModes(glt);
}

void TexMgr_UpdateLightmap(gltexture_t *glt, unsigned int x, unsigned int y, unsigned int width, unsigned int height, const byte *data)
{
	// upload it
	GL_Bind(glt);

#ifdef OPENGLES
	GLenum format = GL_LUMINANCE;
#else
	GLenum format = GL_RED;
#endif

	glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, width, height, format, GL_UNSIGNED_BYTE, data);
}

/* handles 8bit source data, then passes it to LoadImage32 */
static void TexMgr_LoadImage8(gltexture_t *glt, const byte *data, unsigned int width, unsigned int height)
{
	// choose palette and padbyte
	unsigned int *usepal;
//	byte padbyte;
	if (glt->flags & TEX_FULLBRIGHT)
	{
		if (glt->flags & TEX_ALPHA)
			usepal = d_8to24table_fbright_fence;
		else
			usepal = d_8to24table_fbright;
//		padbyte = 0;
	}
	else
	{
		usepal = d_8to24table;
//		padbyte = 255;

		// detect false alpha cases
		if (glt->flags & TEX_ALPHA)
		{
			size_t i, size = (width * height);
			for (i = 0; i < size; i++)
				if (data[i] == 255) //transparent index
					break;
			if (i == size)
				glt->flags &= ~TEX_ALPHA;
		}
	}

	// pad each dimension, but only if it's not going to be downsampled later
//	bool padw = false, padh = false;
//	unsigned int pad_width = TexMgr_SafeTextureSize(glt->width);
//	unsigned int pad_height = TexMgr_SafeTextureSize(glt->height);
//	if ((glt->flags & TEX_PAD) && glt->source_width < pad_width)
//		padw = true;
//	if ((glt->flags & TEX_PAD) && glt->source_height < pad_height)
//		padh = true;
//
//	byte *padded_data;
//	if (padw || padh)
//	{
//		padded_data = (byte *)Q_malloc(sizeof(*padded_data) * (pad_width * pad_height));
//		TexMgr_PadImage8(padded_data, pad_width, pad_height, glt->source_data, glt->source_width, glt->source_height, padbyte);
//	}
//	else
//	{
		const byte *padded_data = data;
		unsigned int pad_width = width;
		unsigned int pad_height = height;
//	}

	// convert to 32bit
	unsigned int *out_data = (unsigned int *)Q_malloc(sizeof(*out_data) * (pad_width * pad_height));
	for (size_t i = 0; i < pad_width * pad_height; i++)
		out_data[i] = usepal[padded_data[i]];

//	if (padw || padh)
//		free(padded_data);

	// fix edges
//	if (glt->flags & TEX_ALPHA)
//		TexMgr_AlphaEdgeFix(out_data, pad_width, pad_height);
//	else
//	{
//		if (padw)
//			TexMgr_PadEdgeFixW(out_data, glt->source_width, glt->source_height);
//		if (padh)
//			TexMgr_PadEdgeFixH(out_data, glt->source_width, glt->source_height);
//	}

	// upload it
	TexMgr_LoadImage32(glt, out_data, pad_width, pad_height);

	free(out_data);
}

static gltexture_t *TexMgr_NewTexture(void)
{
	static size_t numgltextures = 0;
	if (numgltextures == MAX_GLTEXTURES)
		Sys_Error("numgltextures == MAX_GLTEXTURES\n");
	numgltextures++;

	gltexture_t *glt = (gltexture_t *)Q_malloc(sizeof(*glt));

	glGenTextures(1, &glt->texnum);

	glt->next = active_gltextures;
	active_gltextures = glt;

	return glt;
}

/* the one entry point for loading all textures */
gltexture_t *TexMgr_LoadImage(const char *name, int width, int height, enum srcformat format, const byte *data, unsigned flags)
{
	gltexture_t *glt;

	// SRC_RGBA is 4 bytes per pixel, all others are 1
	size_t bpp = (format == SRC_RGBA ? 4 : 1);
	size_t data_size = width * height * bpp;

	// cache check
	unsigned short crc = CRC_Block(data, data_size);
	if ((flags & TEX_OVERWRITE) && (glt = TexMgr_FindTexture(name)))
	{
		if (glt->source_crc == crc)
			return glt;

		free(glt->source_data);
	}
	else
	{
		glt = TexMgr_NewTexture();
		if (glt == NULL)
			return NULL;
	}

	// copy data
	strlcpy(glt->name, name, sizeof(glt->name));
	glt->flags = flags;

	// Keep a copy of original data
	glt->source_data = (byte *)Q_malloc(data_size);
	memcpy(glt->source_data, data, data_size);
	glt->source_format = format;
	glt->source_width = width;
	glt->source_height = height;
	glt->source_crc = crc;

	// HACK HACK HACK -- taken from tomazquake
	if (strstr(glt->name, "shot1sid") &&
	    glt->source_width == 32 &&
	    glt->source_height == 32 &&
	    CRC_Block(glt->source_data, data_size) == 65393)
	{
		// This texture in b_shell1.bsp has some of the first 32 pixels painted white.
		// They are invisible in software, but look really ugly in GL. So we just copy
		// 32 pixels from the bottom to make it look nice.
		memcpy(glt->source_data, glt->source_data + (32 * 31), 32);
	}

	//upload it
	switch (glt->source_format)
	{
	case SRC_INDEXED:
		TexMgr_LoadImage8(glt, data, width, height);
		break;
	case SRC_LIGHTMAP:
		TexMgr_LoadLightmap(glt, data, width, height);
		break;
	case SRC_RGBA:
		TexMgr_LoadImage32(glt, (const unsigned *)data, width, height);
		break;
	}

	return glt;
}

/*
 ================================================================================

 COLORMAPPING AND TEXTURE RELOADING

 ================================================================================
 */

/* reloads a texture, and colormaps it if needed */
void TexMgr_ReloadImage(gltexture_t *glt, int shirt, int pants)
{
	if (!glt->source_data)
	{
		Con_Printf("TexMgr_ReloadImage: invalid source for %s\n", glt->name);
		return;
	}

	// apply shirt and pants colors
	if (shirt > -1 && pants > -1)
	{
		if (glt->source_format != SRC_INDEXED)
		{
			Con_Printf("TexMgr_ReloadImage: can't colormap a non SRC_INDEXED texture: %s\n", glt->name);
			return;
		}

		// create new translation table
		byte translation[256];
		for (size_t i = 0; i < 256; i++)
			translation[i] = i;

		shirt *= 16;
		if (shirt < 128)
		{
			for (size_t i = 0; i < 16; i++)
				translation[TOP_RANGE + i] = shirt + i;
		}
		else
		{
			for (size_t i = 0; i < 16; i++)
				translation[TOP_RANGE + i] = shirt + 15 - i;
		}

		pants *= 16;
		if (pants < 128)
		{
			for (size_t i = 0; i < 16; i++)
				translation[BOTTOM_RANGE + i] = pants + i;
		}
		else
		{
			for (size_t i = 0; i < 16; i++)
				translation[BOTTOM_RANGE + i] = pants + 15 - i;
		}

		//translate texture
		size_t size = glt->source_width * glt->source_height;
		byte *translated = (byte *)Q_malloc(sizeof(*translated) * size);
		for (size_t i = 0; i < size; i++)
			translated[i] = translation[glt->source_data[i]];


		TexMgr_LoadImage8(glt, translated, glt->source_width, glt->source_height);
		return;
	}

	// upload it
	switch (glt->source_format)
	{
	case SRC_INDEXED:
		TexMgr_LoadImage8(glt, glt->source_data, glt->source_width, glt->source_height);
		break;
	case SRC_LIGHTMAP:
		TexMgr_LoadLightmap(glt, glt->source_data, glt->source_width, glt->source_height);
		break;
	case SRC_RGBA:
		TexMgr_LoadImage32(glt, (const unsigned *)glt->source_data, glt->source_width, glt->source_height);
		break;
	}
}

/* reloads all texture images called when context changes */
void TexMgr_ReloadImages(void)
{
	for (gltexture_t *glt = active_gltextures; glt; glt = glt->next)
	{
		glGenTextures(1, &glt->texnum);
		TexMgr_ReloadImage(glt, -1, -1);
	}
}

static void TexMgr_LoadPalette(void)
{
	byte *src, *dst;

	byte *pal = COM_LoadMallocFile("gfx/palette.lmp");
	if (!pal)
		Sys_Error("Couldn't load gfx/palette.lmp");

	//standard palette
	dst = (byte *) d_8to24table;
	src = pal;
	for (int i = 0; i < 256; i++)
	{
		*dst++ = *src++;
		*dst++ = *src++;
		*dst++ = *src++;
		*dst++ = 255;
	}

	// fullbright palette, 0-223 are transparent (for blending)
	memcpy(d_8to24table_fbright, d_8to24table, 256 * 4);
	for (int i = 0; i < 224; i++)
		d_8to24table_fbright[i] &= 0x00ffffff;

	d_8to24table[255] = 0; // 255 is transparent

	// fullbright palette, for fence textures
	memcpy(d_8to24table_fbright_fence, d_8to24table_fbright, 256 * 4);
	d_8to24table_fbright_fence[255] = 0; // 255 is transparent

	free(pal);
}

/* must be called before any texture loading */
void TexMgr_Init(void)
{
	static byte notexture_data[16] = { //black and pink checker
		104,   0,
		  0, 104,
	};
	static byte nulltexture_data[16] = { //black and blue checker
		 42,   0,
		  0,  42,
	};

	// init texture list
	active_gltextures = NULL;

	// palette
	TexMgr_LoadPalette();

	Cvar_RegisterVariable(&gl_max_size);
	Cvar_RegisterVariable(&gl_texture_anisotropy);
	Cvar_SetCallback(&gl_texture_anisotropy, &TexMgr_Anisotropy_f);
	gl_texturemode.string = (char *) glmodes[glmode_idx].name;
	Cvar_RegisterVariable(&gl_texturemode);
	Cvar_SetCallback(&gl_texturemode, &TexMgr_TextureMode_f);
	Cmd_AddCommand("gl_describetexturemodes", &TexMgr_DescribeTextureModes_f);
	Cmd_AddCommand("imagelist", &TexMgr_Imagelist_f);
#ifndef OPENGLES
	Cmd_AddCommand("imagedump", &TexMgr_Imagedump_f);
#endif

	// poll max size from hardware
	glGetIntegerv(GL_MAX_TEXTURE_SIZE, &gl_hardware_maxsize);

	// load notexture image
	notexture = TexMgr_LoadImage("nulltexture", 2, 2, SRC_INDEXED, notexture_data, TEX_NEAREST | TEX_NOPICMIP);

	// load nulltexture image
	nulltexture = TexMgr_LoadImage("nulltexture", 2, 2, SRC_INDEXED, nulltexture_data, TEX_NEAREST | TEX_NOPICMIP);
}
